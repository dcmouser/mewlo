"""
mverificationmanager.py
Helper for verifications data
"""


# mewlo imports
from ..manager import modelmanager
from ..eventlog.mevent import EFailure, EException
import mverification







class MewloVerificationManager(modelmanager.MewloModelManager):
    """The MewloVerificationManager class helps verification management."""


    def __init__(self, mewlosite, debugmode):
        super(MewloVerificationManager,self).__init__(mewlosite, debugmode, mverification.MewloVerification)

    def startup(self, eventlist):
        super(MewloVerificationManager,self).startup(eventlist)

    def shutdown(self):
        super(MewloVerificationManager,self).shutdown()


    def dumps(self, indent=0):
        """Return a string (with newlines and indents) that displays some debugging useful information about the object."""
        outstr = " "*indent + "MewloVerificationManager (" + self.__class__.__name__ + ") reporting in.\n"
        outstr += self.dumps_description(indent+1)
        return outstr



    def create_verification(self, verification_type):
        """
        Generic creation of a new verification entry.
        """
        verification = self.modelclass()
        verification.verification_type = verification_type
        return verification




    def find_bylongcode(self, verification_code):
        """
        Find a verification entry by long code.
        We don't check for expiration or anything like that here, we just find the matching code.
        ATTN: TODO - this is only useful for LONG codes -- we need something more to choose short codes, such as requiring additional info
        """
        verification = self.modelclass.find_one_bykey({'verification_code':verification_code})
        return verification






    def basic_validation(self, verification, verification_code, request, verification_type_expected, is_shortcode_expected, verification_varname):
        """Perform basic validation (check for expiration, etc.).
        Return failure if it fails."""

        # is this even a valid verification?
        if (verification == None):
            return EFailure("Verification code not found.")

        # does code match?
        if (verification.verification_code != verification_code):
            # verification code failed -- this will only happen for short codes
            failure = verification.increase_failurecount()
            if (failure != None):
                return failure
            return EFailure("This verification code does not match.")

        # sanity check
        if ((verification_code == None) or (verification_code == '')):
            return EFailure("This verification code is blank.")

        # is it marked invalid? (note we must check this before date_consumed, since that will also be set when something is marked invalid).
        if (verification.invalidreason != None):
            return EFailure("This verification code is no longer valid: {0}".format(verification.invalidreason))

        # is it already consumed?
        if (verification.date_consumed != None):
            return EFailure("This verification code was already used on {0}.".format(verification.nice_datestring(verification.date_consumed)))

        # is it expired?
        nowtime = verification.get_nowtime()
        if ((verification.date_expires != None) and (verification.date_expires < nowtime)):
            return EFailure("This verification code has expired.")

        # is it the right type?
        if ((verification_type_expected != None) and (verification.verification_type != verification_type_expected)):
            return EFailure("This verification code is not of the expected type.")

        # is it the right fieldname(varname)?
        if ((verification_varname != None) and (verification.verification_varname != verification_varname)):
            return EFailure("This field specified does not match expectations.")

        # short codes must match client session or use
        if (verification.is_shortcode):
            session = request.get_session(False)
            if (session == None):
                # no session for current client, that's going to be a fail, just a matter of how we explain it to user
                if (verification.user_id == None):
                    # this request was generated by a non-logged-in user, and the current client has no session, so advise them to make sure sessions are possible via cookies
                    return EFailure("This short verification code cannot be used because you were not recognized as the same person who generated it.  Please ensure that your browser accepts cookies and then request a new code.")
                else:
                    # since this code was requested by a logged in user, we can tell them to log in first
                    return EFailure("This short verification code cannot be used because you were not recognized as the same person who generated it.  Please login first.")
            # ok there is a session for this user client (could be a logged in user or session could be == None)
            user = session.get_user()
            if ((verification.user_id != None) and (user != None) and (verification.user_id == user.id)):
                # ok we matched the logged in user -- so that's good enough for us, regardless if session matches
                pass
            elif ((verification.session_id != None) and (verification.session_id == session.id)):
                # ok the session id matches -- that's good enough for us
                pass
            else:
                # ok they do not match the session id or user id
                return EFailure("This short verification code cannot be used because you were not recognized as the same person who generated it.  Please request a new code.")

        # it's good, no error
        return None






    def find_byshortcode(self, verification_type, request, fieldname):
        """
        Find a verification entry by type and request session/user info.
        We don't check for expiration or anything like that here, we just find the matching code.
        IMPORTANT: Note that we don't look it up by code!! That's because there can only be one short code per type+user/session; that is how we ensure that they can't try all possible codes.
        On basic validation we will check actual code.
        """
        # build the where clause
        whereclause = self.build_whereclause_verifications_by_type_and_request(verification_type, request, fieldname, None, False)
        if (whereclause == None):
            return None

        # ok find it
        verification = self.modelclass.find_one_bywhereclause(whereclause)
        return verification



    def invalidate_previousverifications(self, verification_type, request, fieldname, invalidreason):
        """
        We often want to invalidate previous verification entries from a user of a specific type, before creating a new one of the same type, so that there is only one pending verification usable at a time.
        """

        # build the where clause
        whereclause = self.build_whereclause_verifications_by_type_and_request(verification_type, request, fieldname, None, False)
        if (whereclause == None):
            return

        # if we wanted we could outright DELETE these verifications
        if (False):
            self.modelclass.delete_all_bywhereclause(whereclause)
        else:
            # or we could mark them as invalidated but leave them in place in order to give user a better error if they try to use it
            updatedict = {
                'invalidreason': invalidreason,
                'date_consumed': self.modelclass.get_nowtime()
            }
            # add sessionip
            session = request.get_session(False)
            if (session != None):
                updatedict['ip_consumed'] = session.ip
            # ok update them
            self.modelclass.update_all_dict_bywhereclause(updatedict, whereclause)



    def build_whereclause_verifications_by_type_and_request(self, verification_type, request, fieldname, user_id, flag_onlyvalid):
        """Build whereclause to select the verifications.
        We want to identify all verifications that match: verification_type AND (EITHER the sessionid or userid)
        """

        # build the where clause
        whereclause = 'verification_type = "{0}"'.format(verification_type)

        # get session information for user, if none, then we have no user or session so nothing to do
        if (request != None):
            session = request.get_session(False)
            if (request != None):
                if (session == None):
                    return None
                user = session.get_user()
                if (user == None):
                    whereclause += ' AND session_id = {0}'.format(session.id)
                else:
                    whereclause += ' AND (session_id = {0} OR user_id = {1})'.format(session.id, user.id)

        # add fieldname match
        if (fieldname != None):
            whereclause += ' AND verification_varname = "{0}"'.format(fieldname)

        # add user_id match
        if (user_id != None):
            whereclause += ' AND user_id = {0}'.format(user_id)

        # only valid?
        if (flag_onlyvalid):
            nowtime = self.modelclass.get_nowtime()
            whereclause += ' AND invalidreason is NULL AND date_consumed is NULL and date_expires > {0}'.format(nowtime)

        #print "WHERE CLAUSE = {0}.".format(whereclause)

        # return it
        return whereclause



    def find_valid_by_type_and_request(self, verification_type, request, fieldname):
        """Find verification and return it, but only if it's also valid!"""
        # build the where clause
        whereclause = self.build_whereclause_verifications_by_type_and_request(verification_type, request, fieldname, None, True)
        if (whereclause == None):
            return None
        # ok find it (a user could create multiple accounts during the same session in which case there might be multiple of these valid verifications pending, and we are only returning first, but there is no harm in that that i can think of; we might want to offer them a way to explicitly CANCEL a registration attempt).
        verification = self.modelclass.find_one_bywhereclause(whereclause)
        return verification


    def find_valid_by_type_and_userid(self, verification_type, user_id, fieldname):
        """Find verification and return it, but only if it's also valid!"""
        # build the where clause
        whereclause = self.build_whereclause_verifications_by_type_and_request(verification_type, None, fieldname, user_id, True)
        if (whereclause == None):
            return None
        # ok find it (a user could create multiple accounts during the same session in which case there might be multiple of these valid verifications pending, and we are only returning first, but there is no harm in that that i can think of; we might want to offer them a way to explicitly CANCEL a registration attempt).
        verification = self.modelclass.find_one_bywhereclause(whereclause)
        return verification



    def get_user_from_verification(self, verification):
        """Return user object from user_id."""
        user = self.sitecomp_usermanager().finduser_byid(verification.user_id)
        return user
